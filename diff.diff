diff --git a/cactus/models/model_moonshine.cpp b/cactus/models/model_moonshine.cpp
index dc7de65..3b22312 100644
--- a/cactus/models/model_moonshine.cpp
+++ b/cactus/models/model_moonshine.cpp
@@ -7,8 +7,26 @@
 #include <set>
 #include <iostream>
 #include <algorithm>
+#include <cstdlib>
 namespace cactus {
 namespace engine {
+
+static size_t moonshine_downsampled_len(size_t audio_len) {
+    if (audio_len < 127) {
+        return 0;
+    }
+    size_t l1 = (audio_len - 127) / 64 + 1;
+    if (l1 < 7) {
+        return 0;
+    }
+    size_t l2 = (l1 - 7) / 3 + 1;
+    if (l2 < 3) {
+        return 0;
+    }
+    size_t l3 = (l2 - 1) / 2 + 1;
+    return l3;
+}
+
 MoonshineModel::MoonshineModel() : Model() {}
 MoonshineModel::MoonshineModel(const Config& config) : Model(config) {
     weight_nodes_.encoder_layers.resize(config.num_encoder_layers);
@@ -55,7 +73,7 @@ void MoonshineModel::load_weights_to_graph(CactusGraph* gb) {
         weight_nodes_.encoder_norm_bias = gb->mmap_weights(model_folder_path_ + "/encoder_norm_bias.bias");
         weight_nodes_.encoder_layer_norm_weight = gb->mmap_weights(model_folder_path_ + "/encoder_layer_norm_weight.weights"); 
     }
-        for (uint32_t i = 0; i < config_.num_decoder_layers; i++) {
+    for (uint32_t i = 0; i < config_.num_decoder_layers; i++) {
         auto& layer = weight_nodes_.decoder_layers[i];
         std::string layer_prefix = model_folder_path_ + "/layer_" + std::to_string(i) + "_";
         layer.decoder_encoder_attn_k_weight = gb->mmap_weights(layer_prefix + "encoder_attn_k.weights");
@@ -376,19 +394,6 @@ size_t MoonshineModel::build_encoder(CactusGraph* gb, const std::vector<float>&
         (void)sum_val;
     }
     if (use_npu_encoder_ && npu_encoder_ && npu_encoder_->is_available()) {
-        std::vector<int> out_shape = npu_encoder_->get_output_shape();
-        size_t T_enc, D_enc;
-        if (out_shape.size() == 3) {
-            T_enc = static_cast<size_t>(out_shape[1]);
-            D_enc = static_cast<size_t>(out_shape[2]);
-        }
-        else if (out_shape.size() == 2) {
-            T_enc = static_cast<size_t>(out_shape[0]);
-            D_enc = static_cast<size_t>(out_shape[1]);
-        }
-        else {
-            throw std::runtime_error("NPU encoder output has unexpected shape");
-        }
         std::vector<int> input_shape = npu_encoder_->get_input_shape();
         if (input_shape.size() != 3) {
             input_shape = {1, 1, static_cast<int>(audio_features.size())};
@@ -402,49 +407,59 @@ size_t MoonshineModel::build_encoder(CactusGraph* gb, const std::vector<float>&
         if (copy_samples > 0) {
             cactus_fp32_to_fp16(audio_features.data(), audio_f16.data(), copy_samples);
         }
-        __fp16* output_buffer = npu_encoder_->get_output_buffer();
-        if (output_buffer) {
-            size_t elements_written = npu_encoder_->encode(
-                audio_f16.data(),
-                output_buffer,  
-                input_shape,
-                "x",
-                ""
-            );
-            if (elements_written > 0) {
-                size_t enc_output_node = gb->input({T_enc, D_enc}, Precision::FP16);
-                gb->set_input(enc_output_node, output_buffer, Precision::FP16);
-                size_t enc_output_persistent = gb->persistent(enc_output_node);
-                last_encoder_post_norm_node_ = enc_output_persistent;
-                return enc_output_persistent;
-            }
+        size_t elements_written = npu_encoder_->encode(
+            audio_f16.data(),
+            nullptr,
+            input_shape,
+            "x",
+            ""
+        );
+        std::vector<int> out_shape = npu_encoder_->get_output_shape();
+        size_t T_enc = 0;
+        size_t D_enc = 0;
+        if (out_shape.size() == 3) {
+            T_enc = static_cast<size_t>(out_shape[1]);
+            D_enc = static_cast<size_t>(out_shape[2]);
+        }
+        else if (out_shape.size() == 2) {
+            T_enc = static_cast<size_t>(out_shape[0]);
+            D_enc = static_cast<size_t>(out_shape[1]);
         }
         else {
-            std::vector<__fp16> npu_output(T_enc * D_enc);
-            size_t elements_written = npu_encoder_->encode(
-                audio_f16.data(),
-                npu_output.data(),
-                input_shape,
-                "x",
-                ""
-            );
-            if (elements_written > 0) {
-                size_t enc_output_node = gb->input({T_enc, D_enc}, Precision::FP16);
-                gb->set_input(enc_output_node, npu_output.data(), Precision::FP16);
-                size_t enc_output_persistent = gb->persistent(enc_output_node);
-                last_encoder_post_norm_node_ = enc_output_persistent;
-                return enc_output_persistent;
-            }
+            std::cout << "NPU encoder output has unexpected shape: " << out_shape.size() << std::endl;
+            std::cout << "Falling back to CPU encoder path." << std::endl;
+            goto encoder_cpu_fallback;
+        }
+        
+        size_t total_elements = T_enc * D_enc;
+        std::vector<__fp16> npu_output(total_elements);
+        elements_written = npu_encoder_->encode(
+            audio_f16.data(),
+            npu_output.data(),
+            input_shape,
+            "x",
+            ""
+        );
+        if (elements_written > 0) {
+            size_t enc_output_node = gb->input({T_enc, D_enc}, Precision::FP16);
+            gb->set_input(enc_output_node, npu_output.data(), Precision::FP16);
+            size_t enc_output_persistent = gb->persistent(enc_output_node);
+            last_encoder_post_norm_node_ = enc_output_persistent;
+            return enc_output_persistent;
         }
     }
+encoder_cpu_fallback:
     auto backend =
         (config_.default_backend == Config::Backend::CPU)
         ? ComputeBackend::CPU
         : ComputeBackend::NPU;
     size_t audio_input = 0;
-    std::vector<__fp16> audio_f16(audio_features.size());
-    cactus_fp32_to_fp16(audio_features.data(), audio_f16.data(), audio_features.size());
-    size_t audio_length = audio_features.size();  
+    const std::vector<float>* cpu_audio = &audio_features;
+    std::vector<__fp16> audio_f16(cpu_audio->size());
+    if (!cpu_audio->empty()) {
+        cactus_fp32_to_fp16(cpu_audio->data(), audio_f16.data(), cpu_audio->size());
+    }
+    size_t audio_length = cpu_audio->size();  
     audio_input = gb->input({1, 1, audio_length}, Precision::FP16);
     gb->set_input(audio_input, audio_f16.data(), Precision::FP16);
     size_t conv2_transposed = build_audio_preprocessor(gb, audio_input);
@@ -542,16 +557,9 @@ uint32_t MoonshineModel::decode_with_audio(
     if (!initialized_ || !graph_handle_)
         throw std::runtime_error("Model not initialized - call init() first");
     if (audio_features.empty())
-        throw std::runtime_error("Audio features cannot be empty in Moonshine decode_with_audio");
-
-    if (temperature <= 0) {
-        temperature = 0.0f; 
-    }
-    if (top_k == 0) {
-        top_k = 1; 
-    }
-
+        throw std::runtime_error("Mel bins cannot be empty in Moonshine decode_with_audio");
     auto* gb = static_cast<CactusGraph*>(graph_handle_);
+    gb->clear_debug_nodes();
     bool cold_start = !encoder_ready_;
     size_t logits_node = 0;
     uint32_t bos = static_cast<uint32_t>(get_tokenizer()->get_bos_token());
